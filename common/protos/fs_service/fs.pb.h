// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_fs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_fs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_fs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_fs_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_fs_2eproto;
class CloseRequest;
struct CloseRequestDefaultTypeInternal;
extern CloseRequestDefaultTypeInternal _CloseRequest_default_instance_;
class DeleteBlockRequest;
struct DeleteBlockRequestDefaultTypeInternal;
extern DeleteBlockRequestDefaultTypeInternal _DeleteBlockRequest_default_instance_;
class DeleteFileRequest;
struct DeleteFileRequestDefaultTypeInternal;
extern DeleteFileRequestDefaultTypeInternal _DeleteFileRequest_default_instance_;
class GetBlockInfoRequest;
struct GetBlockInfoRequestDefaultTypeInternal;
extern GetBlockInfoRequestDefaultTypeInternal _GetBlockInfoRequest_default_instance_;
class GetBlockInfoResponse;
struct GetBlockInfoResponseDefaultTypeInternal;
extern GetBlockInfoResponseDefaultTypeInternal _GetBlockInfoResponse_default_instance_;
class HeartBeatRequest;
struct HeartBeatRequestDefaultTypeInternal;
extern HeartBeatRequestDefaultTypeInternal _HeartBeatRequest_default_instance_;
class HeartBeatResponse;
struct HeartBeatResponseDefaultTypeInternal;
extern HeartBeatResponseDefaultTypeInternal _HeartBeatResponse_default_instance_;
class LsRequest;
struct LsRequestDefaultTypeInternal;
extern LsRequestDefaultTypeInternal _LsRequest_default_instance_;
class LsResponse;
struct LsResponseDefaultTypeInternal;
extern LsResponseDefaultTypeInternal _LsResponse_default_instance_;
class MkdirRequest;
struct MkdirRequestDefaultTypeInternal;
extern MkdirRequestDefaultTypeInternal _MkdirRequest_default_instance_;
class MountRequest;
struct MountRequestDefaultTypeInternal;
extern MountRequestDefaultTypeInternal _MountRequest_default_instance_;
class OpenRequest;
struct OpenRequestDefaultTypeInternal;
extern OpenRequestDefaultTypeInternal _OpenRequest_default_instance_;
class OpenResponse;
struct OpenResponseDefaultTypeInternal;
extern OpenResponseDefaultTypeInternal _OpenResponse_default_instance_;
class ReadBlockRequest;
struct ReadBlockRequestDefaultTypeInternal;
extern ReadBlockRequestDefaultTypeInternal _ReadBlockRequest_default_instance_;
class ReadBlockResponse;
struct ReadBlockResponseDefaultTypeInternal;
extern ReadBlockResponseDefaultTypeInternal _ReadBlockResponse_default_instance_;
class ReadRequest;
struct ReadRequestDefaultTypeInternal;
extern ReadRequestDefaultTypeInternal _ReadRequest_default_instance_;
class ReadResponse;
struct ReadResponseDefaultTypeInternal;
extern ReadResponseDefaultTypeInternal _ReadResponse_default_instance_;
class RmdirRequest;
struct RmdirRequestDefaultTypeInternal;
extern RmdirRequestDefaultTypeInternal _RmdirRequest_default_instance_;
class StatusResponse;
struct StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
class WriteBlockRequest;
struct WriteBlockRequestDefaultTypeInternal;
extern WriteBlockRequestDefaultTypeInternal _WriteBlockRequest_default_instance_;
class WriteRequest;
struct WriteRequestDefaultTypeInternal;
extern WriteRequestDefaultTypeInternal _WriteRequest_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CloseRequest* Arena::CreateMaybeMessage<::CloseRequest>(Arena*);
template<> ::DeleteBlockRequest* Arena::CreateMaybeMessage<::DeleteBlockRequest>(Arena*);
template<> ::DeleteFileRequest* Arena::CreateMaybeMessage<::DeleteFileRequest>(Arena*);
template<> ::GetBlockInfoRequest* Arena::CreateMaybeMessage<::GetBlockInfoRequest>(Arena*);
template<> ::GetBlockInfoResponse* Arena::CreateMaybeMessage<::GetBlockInfoResponse>(Arena*);
template<> ::HeartBeatRequest* Arena::CreateMaybeMessage<::HeartBeatRequest>(Arena*);
template<> ::HeartBeatResponse* Arena::CreateMaybeMessage<::HeartBeatResponse>(Arena*);
template<> ::LsRequest* Arena::CreateMaybeMessage<::LsRequest>(Arena*);
template<> ::LsResponse* Arena::CreateMaybeMessage<::LsResponse>(Arena*);
template<> ::MkdirRequest* Arena::CreateMaybeMessage<::MkdirRequest>(Arena*);
template<> ::MountRequest* Arena::CreateMaybeMessage<::MountRequest>(Arena*);
template<> ::OpenRequest* Arena::CreateMaybeMessage<::OpenRequest>(Arena*);
template<> ::OpenResponse* Arena::CreateMaybeMessage<::OpenResponse>(Arena*);
template<> ::ReadBlockRequest* Arena::CreateMaybeMessage<::ReadBlockRequest>(Arena*);
template<> ::ReadBlockResponse* Arena::CreateMaybeMessage<::ReadBlockResponse>(Arena*);
template<> ::ReadRequest* Arena::CreateMaybeMessage<::ReadRequest>(Arena*);
template<> ::ReadResponse* Arena::CreateMaybeMessage<::ReadResponse>(Arena*);
template<> ::RmdirRequest* Arena::CreateMaybeMessage<::RmdirRequest>(Arena*);
template<> ::StatusResponse* Arena::CreateMaybeMessage<::StatusResponse>(Arena*);
template<> ::WriteBlockRequest* Arena::CreateMaybeMessage<::WriteBlockRequest>(Arena*);
template<> ::WriteRequest* Arena::CreateMaybeMessage<::WriteRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class MountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MountRequest) */ {
 public:
  inline MountRequest() : MountRequest(nullptr) {}
  ~MountRequest() override;
  explicit PROTOBUF_CONSTEXPR MountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MountRequest(const MountRequest& from);
  MountRequest(MountRequest&& from) noexcept
    : MountRequest() {
    *this = ::std::move(from);
  }

  inline MountRequest& operator=(const MountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MountRequest& operator=(MountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MountRequest* internal_default_instance() {
    return reinterpret_cast<const MountRequest*>(
               &_MountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MountRequest& a, MountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MountRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MountRequest& from) {
    MountRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MountRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MountRequest";
  }
  protected:
  explicit MountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:MountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class OpenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenRequest) */ {
 public:
  inline OpenRequest() : OpenRequest(nullptr) {}
  ~OpenRequest() override;
  explicit PROTOBUF_CONSTEXPR OpenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenRequest(const OpenRequest& from);
  OpenRequest(OpenRequest&& from) noexcept
    : OpenRequest() {
    *this = ::std::move(from);
  }

  inline OpenRequest& operator=(const OpenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenRequest& operator=(OpenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenRequest* internal_default_instance() {
    return reinterpret_cast<const OpenRequest*>(
               &_OpenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OpenRequest& a, OpenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpenRequest& from) {
    OpenRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenRequest";
  }
  protected:
  explicit OpenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kPathFieldNumber = 2,
    kModeFieldNumber = 3,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string mode = 3;
  void clear_mode();
  const std::string& mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mode();
  PROTOBUF_NODISCARD std::string* release_mode();
  void set_allocated_mode(std::string* mode);
  private:
  const std::string& _internal_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mode(const std::string& value);
  std::string* _internal_mutable_mode();
  public:

  // @@protoc_insertion_point(class_scope:OpenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class OpenResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenResponse) */ {
 public:
  inline OpenResponse() : OpenResponse(nullptr) {}
  ~OpenResponse() override;
  explicit PROTOBUF_CONSTEXPR OpenResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenResponse(const OpenResponse& from);
  OpenResponse(OpenResponse&& from) noexcept
    : OpenResponse() {
    *this = ::std::move(from);
  }

  inline OpenResponse& operator=(const OpenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenResponse& operator=(OpenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenResponse* internal_default_instance() {
    return reinterpret_cast<const OpenResponse*>(
               &_OpenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OpenResponse& a, OpenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpenResponse& from) {
    OpenResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenResponse";
  }
  protected:
  explicit OpenResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kFdFieldNumber = 1,
  };
  // string error = 2;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // int32 fd = 1;
  void clear_fd();
  int32_t fd() const;
  void set_fd(int32_t value);
  private:
  int32_t _internal_fd() const;
  void _internal_set_fd(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OpenResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    int32_t fd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class CloseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CloseRequest) */ {
 public:
  inline CloseRequest() : CloseRequest(nullptr) {}
  ~CloseRequest() override;
  explicit PROTOBUF_CONSTEXPR CloseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseRequest(const CloseRequest& from);
  CloseRequest(CloseRequest&& from) noexcept
    : CloseRequest() {
    *this = ::std::move(from);
  }

  inline CloseRequest& operator=(const CloseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseRequest& operator=(CloseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseRequest* internal_default_instance() {
    return reinterpret_cast<const CloseRequest*>(
               &_CloseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CloseRequest& a, CloseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CloseRequest& from) {
    CloseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CloseRequest";
  }
  protected:
  explicit CloseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kFdFieldNumber = 2,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // int32 fd = 2;
  void clear_fd();
  int32_t fd() const;
  void set_fd(int32_t value);
  private:
  int32_t _internal_fd() const;
  void _internal_set_fd(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CloseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    int32_t fd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class ReadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReadRequest) */ {
 public:
  inline ReadRequest() : ReadRequest(nullptr) {}
  ~ReadRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadRequest(const ReadRequest& from);
  ReadRequest(ReadRequest&& from) noexcept
    : ReadRequest() {
    *this = ::std::move(from);
  }

  inline ReadRequest& operator=(const ReadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRequest& operator=(ReadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadRequest* internal_default_instance() {
    return reinterpret_cast<const ReadRequest*>(
               &_ReadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReadRequest& a, ReadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadRequest& from) {
    ReadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReadRequest";
  }
  protected:
  explicit ReadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kFdFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // int32 fd = 2;
  void clear_fd();
  int32_t fd() const;
  void set_fd(int32_t value);
  private:
  int32_t _internal_fd() const;
  void _internal_set_fd(int32_t value);
  public:

  // int32 count = 3;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    int32_t fd_;
    int32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class ReadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReadResponse) */ {
 public:
  inline ReadResponse() : ReadResponse(nullptr) {}
  ~ReadResponse() override;
  explicit PROTOBUF_CONSTEXPR ReadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadResponse(const ReadResponse& from);
  ReadResponse(ReadResponse&& from) noexcept
    : ReadResponse() {
    *this = ::std::move(from);
  }

  inline ReadResponse& operator=(const ReadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadResponse& operator=(ReadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadResponse* internal_default_instance() {
    return reinterpret_cast<const ReadResponse*>(
               &_ReadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ReadResponse& a, ReadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadResponse& from) {
    ReadResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReadResponse";
  }
  protected:
  explicit ReadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kBytesReadFieldNumber = 2,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int32 bytes_read = 2;
  void clear_bytes_read();
  int32_t bytes_read() const;
  void set_bytes_read(int32_t value);
  private:
  int32_t _internal_bytes_read() const;
  void _internal_set_bytes_read(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int32_t bytes_read_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class WriteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WriteRequest) */ {
 public:
  inline WriteRequest() : WriteRequest(nullptr) {}
  ~WriteRequest() override;
  explicit PROTOBUF_CONSTEXPR WriteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteRequest(const WriteRequest& from);
  WriteRequest(WriteRequest&& from) noexcept
    : WriteRequest() {
    *this = ::std::move(from);
  }

  inline WriteRequest& operator=(const WriteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteRequest& operator=(WriteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteRequest* internal_default_instance() {
    return reinterpret_cast<const WriteRequest*>(
               &_WriteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WriteRequest& a, WriteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WriteRequest& from) {
    WriteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WriteRequest";
  }
  protected:
  explicit WriteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kDataFieldNumber = 4,
    kFdFieldNumber = 2,
    kOffsetFieldNumber = 3,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int32 fd = 2;
  void clear_fd();
  int32_t fd() const;
  void set_fd(int32_t value);
  private:
  int32_t _internal_fd() const;
  void _internal_set_fd(int32_t value);
  public:

  // uint32 offset = 3;
  void clear_offset();
  uint32_t offset() const;
  void set_offset(uint32_t value);
  private:
  uint32_t _internal_offset() const;
  void _internal_set_offset(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:WriteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int32_t fd_;
    uint32_t offset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class DeleteFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DeleteFileRequest) */ {
 public:
  inline DeleteFileRequest() : DeleteFileRequest(nullptr) {}
  ~DeleteFileRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFileRequest(const DeleteFileRequest& from);
  DeleteFileRequest(DeleteFileRequest&& from) noexcept
    : DeleteFileRequest() {
    *this = ::std::move(from);
  }

  inline DeleteFileRequest& operator=(const DeleteFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFileRequest& operator=(DeleteFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFileRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteFileRequest*>(
               &_DeleteFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DeleteFileRequest& a, DeleteFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteFileRequest& from) {
    DeleteFileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DeleteFileRequest";
  }
  protected:
  explicit DeleteFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:DeleteFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class MkdirRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MkdirRequest) */ {
 public:
  inline MkdirRequest() : MkdirRequest(nullptr) {}
  ~MkdirRequest() override;
  explicit PROTOBUF_CONSTEXPR MkdirRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MkdirRequest(const MkdirRequest& from);
  MkdirRequest(MkdirRequest&& from) noexcept
    : MkdirRequest() {
    *this = ::std::move(from);
  }

  inline MkdirRequest& operator=(const MkdirRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MkdirRequest& operator=(MkdirRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MkdirRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MkdirRequest* internal_default_instance() {
    return reinterpret_cast<const MkdirRequest*>(
               &_MkdirRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MkdirRequest& a, MkdirRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MkdirRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MkdirRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MkdirRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MkdirRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MkdirRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MkdirRequest& from) {
    MkdirRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MkdirRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MkdirRequest";
  }
  protected:
  explicit MkdirRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:MkdirRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class RmdirRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RmdirRequest) */ {
 public:
  inline RmdirRequest() : RmdirRequest(nullptr) {}
  ~RmdirRequest() override;
  explicit PROTOBUF_CONSTEXPR RmdirRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RmdirRequest(const RmdirRequest& from);
  RmdirRequest(RmdirRequest&& from) noexcept
    : RmdirRequest() {
    *this = ::std::move(from);
  }

  inline RmdirRequest& operator=(const RmdirRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RmdirRequest& operator=(RmdirRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RmdirRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RmdirRequest* internal_default_instance() {
    return reinterpret_cast<const RmdirRequest*>(
               &_RmdirRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RmdirRequest& a, RmdirRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RmdirRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RmdirRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RmdirRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RmdirRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RmdirRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RmdirRequest& from) {
    RmdirRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RmdirRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RmdirRequest";
  }
  protected:
  explicit RmdirRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:RmdirRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class LsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LsRequest) */ {
 public:
  inline LsRequest() : LsRequest(nullptr) {}
  ~LsRequest() override;
  explicit PROTOBUF_CONSTEXPR LsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LsRequest(const LsRequest& from);
  LsRequest(LsRequest&& from) noexcept
    : LsRequest() {
    *this = ::std::move(from);
  }

  inline LsRequest& operator=(const LsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LsRequest& operator=(LsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LsRequest* internal_default_instance() {
    return reinterpret_cast<const LsRequest*>(
               &_LsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LsRequest& a, LsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LsRequest& from) {
    LsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LsRequest";
  }
  protected:
  explicit LsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:LsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class LsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LsResponse) */ {
 public:
  inline LsResponse() : LsResponse(nullptr) {}
  ~LsResponse() override;
  explicit PROTOBUF_CONSTEXPR LsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LsResponse(const LsResponse& from);
  LsResponse(LsResponse&& from) noexcept
    : LsResponse() {
    *this = ::std::move(from);
  }

  inline LsResponse& operator=(const LsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LsResponse& operator=(LsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LsResponse* internal_default_instance() {
    return reinterpret_cast<const LsResponse*>(
               &_LsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LsResponse& a, LsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LsResponse& from) {
    LsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LsResponse";
  }
  protected:
  explicit LsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 3,
    kErrorFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated string files = 3;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  const std::string& files(int index) const;
  std::string* mutable_files(int index);
  void set_files(int index, const std::string& value);
  void set_files(int index, std::string&& value);
  void set_files(int index, const char* value);
  void set_files(int index, const char* value, size_t size);
  std::string* add_files();
  void add_files(const std::string& value);
  void add_files(std::string&& value);
  void add_files(const char* value);
  void add_files(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& files() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_files();
  private:
  const std::string& _internal_files(int index) const;
  std::string* _internal_add_files();
  public:

  // string error = 2;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:LsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> files_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class ReadBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReadBlockRequest) */ {
 public:
  inline ReadBlockRequest() : ReadBlockRequest(nullptr) {}
  ~ReadBlockRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadBlockRequest(const ReadBlockRequest& from);
  ReadBlockRequest(ReadBlockRequest&& from) noexcept
    : ReadBlockRequest() {
    *this = ::std::move(from);
  }

  inline ReadBlockRequest& operator=(const ReadBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadBlockRequest& operator=(ReadBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadBlockRequest* internal_default_instance() {
    return reinterpret_cast<const ReadBlockRequest*>(
               &_ReadBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ReadBlockRequest& a, ReadBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadBlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadBlockRequest& from) {
    ReadBlockRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadBlockRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReadBlockRequest";
  }
  protected:
  explicit ReadBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockUuidFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kLengthFieldNumber = 3,
  };
  // uint64 block_uuid = 1;
  void clear_block_uuid();
  uint64_t block_uuid() const;
  void set_block_uuid(uint64_t value);
  private:
  uint64_t _internal_block_uuid() const;
  void _internal_set_block_uuid(uint64_t value);
  public:

  // uint32 offset = 2;
  void clear_offset();
  uint32_t offset() const;
  void set_offset(uint32_t value);
  private:
  uint32_t _internal_offset() const;
  void _internal_set_offset(uint32_t value);
  public:

  // uint32 length = 3;
  void clear_length();
  uint32_t length() const;
  void set_length(uint32_t value);
  private:
  uint32_t _internal_length() const;
  void _internal_set_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReadBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t block_uuid_;
    uint32_t offset_;
    uint32_t length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class ReadBlockResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReadBlockResponse) */ {
 public:
  inline ReadBlockResponse() : ReadBlockResponse(nullptr) {}
  ~ReadBlockResponse() override;
  explicit PROTOBUF_CONSTEXPR ReadBlockResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadBlockResponse(const ReadBlockResponse& from);
  ReadBlockResponse(ReadBlockResponse&& from) noexcept
    : ReadBlockResponse() {
    *this = ::std::move(from);
  }

  inline ReadBlockResponse& operator=(const ReadBlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadBlockResponse& operator=(ReadBlockResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadBlockResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadBlockResponse* internal_default_instance() {
    return reinterpret_cast<const ReadBlockResponse*>(
               &_ReadBlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ReadBlockResponse& a, ReadBlockResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadBlockResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadBlockResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadBlockResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadBlockResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadBlockResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadBlockResponse& from) {
    ReadBlockResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadBlockResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReadBlockResponse";
  }
  protected:
  explicit ReadBlockResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kErrorFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kBytesReadFieldNumber = 4,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string error = 3;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // uint32 bytes_read = 4;
  void clear_bytes_read();
  uint32_t bytes_read() const;
  void set_bytes_read(uint32_t value);
  private:
  uint32_t _internal_bytes_read() const;
  void _internal_set_bytes_read(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReadBlockResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    bool success_;
    uint32_t bytes_read_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class WriteBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WriteBlockRequest) */ {
 public:
  inline WriteBlockRequest() : WriteBlockRequest(nullptr) {}
  ~WriteBlockRequest() override;
  explicit PROTOBUF_CONSTEXPR WriteBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteBlockRequest(const WriteBlockRequest& from);
  WriteBlockRequest(WriteBlockRequest&& from) noexcept
    : WriteBlockRequest() {
    *this = ::std::move(from);
  }

  inline WriteBlockRequest& operator=(const WriteBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteBlockRequest& operator=(WriteBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteBlockRequest* internal_default_instance() {
    return reinterpret_cast<const WriteBlockRequest*>(
               &_WriteBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(WriteBlockRequest& a, WriteBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteBlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WriteBlockRequest& from) {
    WriteBlockRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteBlockRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WriteBlockRequest";
  }
  protected:
  explicit WriteBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kBlockUuidFieldNumber = 1,
    kOffsetFieldNumber = 3,
    kSyncFieldNumber = 4,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint64 block_uuid = 1;
  void clear_block_uuid();
  uint64_t block_uuid() const;
  void set_block_uuid(uint64_t value);
  private:
  uint64_t _internal_block_uuid() const;
  void _internal_set_block_uuid(uint64_t value);
  public:

  // uint32 offset = 3;
  void clear_offset();
  uint32_t offset() const;
  void set_offset(uint32_t value);
  private:
  uint32_t _internal_offset() const;
  void _internal_set_offset(uint32_t value);
  public:

  // bool sync = 4;
  void clear_sync();
  bool sync() const;
  void set_sync(bool value);
  private:
  bool _internal_sync() const;
  void _internal_set_sync(bool value);
  public:

  // @@protoc_insertion_point(class_scope:WriteBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    uint64_t block_uuid_;
    uint32_t offset_;
    bool sync_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class DeleteBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DeleteBlockRequest) */ {
 public:
  inline DeleteBlockRequest() : DeleteBlockRequest(nullptr) {}
  ~DeleteBlockRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteBlockRequest(const DeleteBlockRequest& from);
  DeleteBlockRequest(DeleteBlockRequest&& from) noexcept
    : DeleteBlockRequest() {
    *this = ::std::move(from);
  }

  inline DeleteBlockRequest& operator=(const DeleteBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteBlockRequest& operator=(DeleteBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteBlockRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteBlockRequest*>(
               &_DeleteBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DeleteBlockRequest& a, DeleteBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteBlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteBlockRequest& from) {
    DeleteBlockRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteBlockRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DeleteBlockRequest";
  }
  protected:
  explicit DeleteBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockUuidFieldNumber = 1,
  };
  // uint64 block_uuid = 1;
  void clear_block_uuid();
  uint64_t block_uuid() const;
  void set_block_uuid(uint64_t value);
  private:
  uint64_t _internal_block_uuid() const;
  void _internal_set_block_uuid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:DeleteBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t block_uuid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class GetBlockInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetBlockInfoRequest) */ {
 public:
  inline GetBlockInfoRequest() : GetBlockInfoRequest(nullptr) {}
  ~GetBlockInfoRequest() override;
  explicit PROTOBUF_CONSTEXPR GetBlockInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockInfoRequest(const GetBlockInfoRequest& from);
  GetBlockInfoRequest(GetBlockInfoRequest&& from) noexcept
    : GetBlockInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockInfoRequest& operator=(const GetBlockInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockInfoRequest& operator=(GetBlockInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockInfoRequest*>(
               &_GetBlockInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetBlockInfoRequest& a, GetBlockInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlockInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBlockInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBlockInfoRequest& from) {
    GetBlockInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetBlockInfoRequest";
  }
  protected:
  explicit GetBlockInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockUuidFieldNumber = 1,
  };
  // uint64 block_uuid = 1;
  void clear_block_uuid();
  uint64_t block_uuid() const;
  void set_block_uuid(uint64_t value);
  private:
  uint64_t _internal_block_uuid() const;
  void _internal_set_block_uuid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetBlockInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t block_uuid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class GetBlockInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetBlockInfoResponse) */ {
 public:
  inline GetBlockInfoResponse() : GetBlockInfoResponse(nullptr) {}
  ~GetBlockInfoResponse() override;
  explicit PROTOBUF_CONSTEXPR GetBlockInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockInfoResponse(const GetBlockInfoResponse& from);
  GetBlockInfoResponse(GetBlockInfoResponse&& from) noexcept
    : GetBlockInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetBlockInfoResponse& operator=(const GetBlockInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockInfoResponse& operator=(GetBlockInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetBlockInfoResponse*>(
               &_GetBlockInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetBlockInfoResponse& a, GetBlockInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlockInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBlockInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBlockInfoResponse& from) {
    GetBlockInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetBlockInfoResponse";
  }
  protected:
  explicit GetBlockInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreatedAtFieldNumber = 3,
    kChecksumFieldNumber = 4,
    kSizeFieldNumber = 2,
    kExistsFieldNumber = 1,
  };
  // string created_at = 3;
  void clear_created_at();
  const std::string& created_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_at();
  PROTOBUF_NODISCARD std::string* release_created_at();
  void set_allocated_created_at(std::string* created_at);
  private:
  const std::string& _internal_created_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_at(const std::string& value);
  std::string* _internal_mutable_created_at();
  public:

  // string checksum = 4;
  void clear_checksum();
  const std::string& checksum() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_checksum(ArgT0&& arg0, ArgT... args);
  std::string* mutable_checksum();
  PROTOBUF_NODISCARD std::string* release_checksum();
  void set_allocated_checksum(std::string* checksum);
  private:
  const std::string& _internal_checksum() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_checksum(const std::string& value);
  std::string* _internal_mutable_checksum();
  public:

  // uint64 size = 2;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // bool exists = 1;
  void clear_exists();
  bool exists() const;
  void set_exists(bool value);
  private:
  bool _internal_exists() const;
  void _internal_set_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:GetBlockInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_at_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr checksum_;
    uint64_t size_;
    bool exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class HeartBeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HeartBeatRequest) */ {
 public:
  inline HeartBeatRequest() : HeartBeatRequest(nullptr) {}
  ~HeartBeatRequest() override;
  explicit PROTOBUF_CONSTEXPR HeartBeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartBeatRequest(const HeartBeatRequest& from);
  HeartBeatRequest(HeartBeatRequest&& from) noexcept
    : HeartBeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartBeatRequest& operator=(const HeartBeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartBeatRequest& operator=(HeartBeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartBeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartBeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartBeatRequest*>(
               &_HeartBeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(HeartBeatRequest& a, HeartBeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartBeatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartBeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartBeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartBeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartBeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartBeatRequest& from) {
    HeartBeatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartBeatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HeartBeatRequest";
  }
  protected:
  explicit HeartBeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockUuidsFieldNumber = 2,
    kDatanodeIdFieldNumber = 1,
  };
  // repeated uint64 block_uuids = 2;
  int block_uuids_size() const;
  private:
  int _internal_block_uuids_size() const;
  public:
  void clear_block_uuids();
  private:
  uint64_t _internal_block_uuids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_block_uuids() const;
  void _internal_add_block_uuids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_block_uuids();
  public:
  uint64_t block_uuids(int index) const;
  void set_block_uuids(int index, uint64_t value);
  void add_block_uuids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      block_uuids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_block_uuids();

  // string datanode_id = 1;
  void clear_datanode_id();
  const std::string& datanode_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_datanode_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_datanode_id();
  PROTOBUF_NODISCARD std::string* release_datanode_id();
  void set_allocated_datanode_id(std::string* datanode_id);
  private:
  const std::string& _internal_datanode_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datanode_id(const std::string& value);
  std::string* _internal_mutable_datanode_id();
  public:

  // @@protoc_insertion_point(class_scope:HeartBeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > block_uuids_;
    mutable std::atomic<int> _block_uuids_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datanode_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class HeartBeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HeartBeatResponse) */ {
 public:
  inline HeartBeatResponse() : HeartBeatResponse(nullptr) {}
  ~HeartBeatResponse() override;
  explicit PROTOBUF_CONSTEXPR HeartBeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartBeatResponse(const HeartBeatResponse& from);
  HeartBeatResponse(HeartBeatResponse&& from) noexcept
    : HeartBeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartBeatResponse& operator=(const HeartBeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartBeatResponse& operator=(HeartBeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartBeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartBeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartBeatResponse*>(
               &_HeartBeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(HeartBeatResponse& a, HeartBeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartBeatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartBeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartBeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartBeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartBeatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartBeatResponse& from) {
    HeartBeatResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartBeatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HeartBeatResponse";
  }
  protected:
  explicit HeartBeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string error = 2;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:HeartBeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class StatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StatusResponse) */ {
 public:
  inline StatusResponse() : StatusResponse(nullptr) {}
  ~StatusResponse() override;
  explicit PROTOBUF_CONSTEXPR StatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusResponse(const StatusResponse& from);
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusResponse& from) {
    StatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StatusResponse";
  }
  protected:
  explicit StatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string error = 2;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:StatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MountRequest

// string user_id = 1;
inline void MountRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& MountRequest::user_id() const {
  // @@protoc_insertion_point(field_get:MountRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MountRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MountRequest.user_id)
}
inline std::string* MountRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:MountRequest.user_id)
  return _s;
}
inline const std::string& MountRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void MountRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MountRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MountRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:MountRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void MountRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MountRequest.user_id)
}

// -------------------------------------------------------------------

// OpenRequest

// string user_id = 1;
inline void OpenRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& OpenRequest::user_id() const {
  // @@protoc_insertion_point(field_get:OpenRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpenRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenRequest.user_id)
}
inline std::string* OpenRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:OpenRequest.user_id)
  return _s;
}
inline const std::string& OpenRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void OpenRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OpenRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OpenRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:OpenRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void OpenRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OpenRequest.user_id)
}

// string path = 2;
inline void OpenRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& OpenRequest::path() const {
  // @@protoc_insertion_point(field_get:OpenRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpenRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenRequest.path)
}
inline std::string* OpenRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:OpenRequest.path)
  return _s;
}
inline const std::string& OpenRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void OpenRequest::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* OpenRequest::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* OpenRequest::release_path() {
  // @@protoc_insertion_point(field_release:OpenRequest.path)
  return _impl_.path_.Release();
}
inline void OpenRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OpenRequest.path)
}

// string mode = 3;
inline void OpenRequest::clear_mode() {
  _impl_.mode_.ClearToEmpty();
}
inline const std::string& OpenRequest::mode() const {
  // @@protoc_insertion_point(field_get:OpenRequest.mode)
  return _internal_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpenRequest::set_mode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenRequest.mode)
}
inline std::string* OpenRequest::mutable_mode() {
  std::string* _s = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:OpenRequest.mode)
  return _s;
}
inline const std::string& OpenRequest::_internal_mode() const {
  return _impl_.mode_.Get();
}
inline void OpenRequest::_internal_set_mode(const std::string& value) {
  
  _impl_.mode_.Set(value, GetArenaForAllocation());
}
inline std::string* OpenRequest::_internal_mutable_mode() {
  
  return _impl_.mode_.Mutable(GetArenaForAllocation());
}
inline std::string* OpenRequest::release_mode() {
  // @@protoc_insertion_point(field_release:OpenRequest.mode)
  return _impl_.mode_.Release();
}
inline void OpenRequest::set_allocated_mode(std::string* mode) {
  if (mode != nullptr) {
    
  } else {
    
  }
  _impl_.mode_.SetAllocated(mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mode_.IsDefault()) {
    _impl_.mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OpenRequest.mode)
}

// -------------------------------------------------------------------

// OpenResponse

// int32 fd = 1;
inline void OpenResponse::clear_fd() {
  _impl_.fd_ = 0;
}
inline int32_t OpenResponse::_internal_fd() const {
  return _impl_.fd_;
}
inline int32_t OpenResponse::fd() const {
  // @@protoc_insertion_point(field_get:OpenResponse.fd)
  return _internal_fd();
}
inline void OpenResponse::_internal_set_fd(int32_t value) {
  
  _impl_.fd_ = value;
}
inline void OpenResponse::set_fd(int32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:OpenResponse.fd)
}

// string error = 2;
inline void OpenResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& OpenResponse::error() const {
  // @@protoc_insertion_point(field_get:OpenResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpenResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenResponse.error)
}
inline std::string* OpenResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:OpenResponse.error)
  return _s;
}
inline const std::string& OpenResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void OpenResponse::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* OpenResponse::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* OpenResponse::release_error() {
  // @@protoc_insertion_point(field_release:OpenResponse.error)
  return _impl_.error_.Release();
}
inline void OpenResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OpenResponse.error)
}

// -------------------------------------------------------------------

// CloseRequest

// string user_id = 1;
inline void CloseRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& CloseRequest::user_id() const {
  // @@protoc_insertion_point(field_get:CloseRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloseRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CloseRequest.user_id)
}
inline std::string* CloseRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:CloseRequest.user_id)
  return _s;
}
inline const std::string& CloseRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void CloseRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CloseRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CloseRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:CloseRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void CloseRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CloseRequest.user_id)
}

// int32 fd = 2;
inline void CloseRequest::clear_fd() {
  _impl_.fd_ = 0;
}
inline int32_t CloseRequest::_internal_fd() const {
  return _impl_.fd_;
}
inline int32_t CloseRequest::fd() const {
  // @@protoc_insertion_point(field_get:CloseRequest.fd)
  return _internal_fd();
}
inline void CloseRequest::_internal_set_fd(int32_t value) {
  
  _impl_.fd_ = value;
}
inline void CloseRequest::set_fd(int32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:CloseRequest.fd)
}

// -------------------------------------------------------------------

// ReadRequest

// string user_id = 1;
inline void ReadRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& ReadRequest::user_id() const {
  // @@protoc_insertion_point(field_get:ReadRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReadRequest.user_id)
}
inline std::string* ReadRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ReadRequest.user_id)
  return _s;
}
inline const std::string& ReadRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void ReadRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:ReadRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void ReadRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReadRequest.user_id)
}

// int32 fd = 2;
inline void ReadRequest::clear_fd() {
  _impl_.fd_ = 0;
}
inline int32_t ReadRequest::_internal_fd() const {
  return _impl_.fd_;
}
inline int32_t ReadRequest::fd() const {
  // @@protoc_insertion_point(field_get:ReadRequest.fd)
  return _internal_fd();
}
inline void ReadRequest::_internal_set_fd(int32_t value) {
  
  _impl_.fd_ = value;
}
inline void ReadRequest::set_fd(int32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:ReadRequest.fd)
}

// int32 count = 3;
inline void ReadRequest::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t ReadRequest::_internal_count() const {
  return _impl_.count_;
}
inline int32_t ReadRequest::count() const {
  // @@protoc_insertion_point(field_get:ReadRequest.count)
  return _internal_count();
}
inline void ReadRequest::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void ReadRequest::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:ReadRequest.count)
}

// -------------------------------------------------------------------

// ReadResponse

// bytes data = 1;
inline void ReadResponse::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ReadResponse::data() const {
  // @@protoc_insertion_point(field_get:ReadResponse.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadResponse::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReadResponse.data)
}
inline std::string* ReadResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ReadResponse.data)
  return _s;
}
inline const std::string& ReadResponse::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ReadResponse::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadResponse::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadResponse::release_data() {
  // @@protoc_insertion_point(field_release:ReadResponse.data)
  return _impl_.data_.Release();
}
inline void ReadResponse::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReadResponse.data)
}

// int32 bytes_read = 2;
inline void ReadResponse::clear_bytes_read() {
  _impl_.bytes_read_ = 0;
}
inline int32_t ReadResponse::_internal_bytes_read() const {
  return _impl_.bytes_read_;
}
inline int32_t ReadResponse::bytes_read() const {
  // @@protoc_insertion_point(field_get:ReadResponse.bytes_read)
  return _internal_bytes_read();
}
inline void ReadResponse::_internal_set_bytes_read(int32_t value) {
  
  _impl_.bytes_read_ = value;
}
inline void ReadResponse::set_bytes_read(int32_t value) {
  _internal_set_bytes_read(value);
  // @@protoc_insertion_point(field_set:ReadResponse.bytes_read)
}

// -------------------------------------------------------------------

// WriteRequest

// string user_id = 1;
inline void WriteRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& WriteRequest::user_id() const {
  // @@protoc_insertion_point(field_get:WriteRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WriteRequest.user_id)
}
inline std::string* WriteRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:WriteRequest.user_id)
  return _s;
}
inline const std::string& WriteRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void WriteRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:WriteRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void WriteRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:WriteRequest.user_id)
}

// int32 fd = 2;
inline void WriteRequest::clear_fd() {
  _impl_.fd_ = 0;
}
inline int32_t WriteRequest::_internal_fd() const {
  return _impl_.fd_;
}
inline int32_t WriteRequest::fd() const {
  // @@protoc_insertion_point(field_get:WriteRequest.fd)
  return _internal_fd();
}
inline void WriteRequest::_internal_set_fd(int32_t value) {
  
  _impl_.fd_ = value;
}
inline void WriteRequest::set_fd(int32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:WriteRequest.fd)
}

// uint32 offset = 3;
inline void WriteRequest::clear_offset() {
  _impl_.offset_ = 0u;
}
inline uint32_t WriteRequest::_internal_offset() const {
  return _impl_.offset_;
}
inline uint32_t WriteRequest::offset() const {
  // @@protoc_insertion_point(field_get:WriteRequest.offset)
  return _internal_offset();
}
inline void WriteRequest::_internal_set_offset(uint32_t value) {
  
  _impl_.offset_ = value;
}
inline void WriteRequest::set_offset(uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:WriteRequest.offset)
}

// bytes data = 4;
inline void WriteRequest::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& WriteRequest::data() const {
  // @@protoc_insertion_point(field_get:WriteRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WriteRequest.data)
}
inline std::string* WriteRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:WriteRequest.data)
  return _s;
}
inline const std::string& WriteRequest::_internal_data() const {
  return _impl_.data_.Get();
}
inline void WriteRequest::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteRequest::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteRequest::release_data() {
  // @@protoc_insertion_point(field_release:WriteRequest.data)
  return _impl_.data_.Release();
}
inline void WriteRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:WriteRequest.data)
}

// -------------------------------------------------------------------

// DeleteFileRequest

// string user_id = 1;
inline void DeleteFileRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& DeleteFileRequest::user_id() const {
  // @@protoc_insertion_point(field_get:DeleteFileRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFileRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeleteFileRequest.user_id)
}
inline std::string* DeleteFileRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:DeleteFileRequest.user_id)
  return _s;
}
inline const std::string& DeleteFileRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void DeleteFileRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteFileRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteFileRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:DeleteFileRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void DeleteFileRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeleteFileRequest.user_id)
}

// string path = 2;
inline void DeleteFileRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& DeleteFileRequest::path() const {
  // @@protoc_insertion_point(field_get:DeleteFileRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFileRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeleteFileRequest.path)
}
inline std::string* DeleteFileRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:DeleteFileRequest.path)
  return _s;
}
inline const std::string& DeleteFileRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void DeleteFileRequest::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteFileRequest::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteFileRequest::release_path() {
  // @@protoc_insertion_point(field_release:DeleteFileRequest.path)
  return _impl_.path_.Release();
}
inline void DeleteFileRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeleteFileRequest.path)
}

// -------------------------------------------------------------------

// MkdirRequest

// string user_id = 1;
inline void MkdirRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& MkdirRequest::user_id() const {
  // @@protoc_insertion_point(field_get:MkdirRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MkdirRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MkdirRequest.user_id)
}
inline std::string* MkdirRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:MkdirRequest.user_id)
  return _s;
}
inline const std::string& MkdirRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void MkdirRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MkdirRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MkdirRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:MkdirRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void MkdirRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MkdirRequest.user_id)
}

// string path = 2;
inline void MkdirRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& MkdirRequest::path() const {
  // @@protoc_insertion_point(field_get:MkdirRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MkdirRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MkdirRequest.path)
}
inline std::string* MkdirRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:MkdirRequest.path)
  return _s;
}
inline const std::string& MkdirRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void MkdirRequest::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* MkdirRequest::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* MkdirRequest::release_path() {
  // @@protoc_insertion_point(field_release:MkdirRequest.path)
  return _impl_.path_.Release();
}
inline void MkdirRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MkdirRequest.path)
}

// -------------------------------------------------------------------

// RmdirRequest

// string user_id = 1;
inline void RmdirRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& RmdirRequest::user_id() const {
  // @@protoc_insertion_point(field_get:RmdirRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RmdirRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RmdirRequest.user_id)
}
inline std::string* RmdirRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:RmdirRequest.user_id)
  return _s;
}
inline const std::string& RmdirRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void RmdirRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RmdirRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RmdirRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:RmdirRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void RmdirRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RmdirRequest.user_id)
}

// string path = 2;
inline void RmdirRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& RmdirRequest::path() const {
  // @@protoc_insertion_point(field_get:RmdirRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RmdirRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RmdirRequest.path)
}
inline std::string* RmdirRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:RmdirRequest.path)
  return _s;
}
inline const std::string& RmdirRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void RmdirRequest::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* RmdirRequest::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* RmdirRequest::release_path() {
  // @@protoc_insertion_point(field_release:RmdirRequest.path)
  return _impl_.path_.Release();
}
inline void RmdirRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RmdirRequest.path)
}

// -------------------------------------------------------------------

// LsRequest

// string user_id = 1;
inline void LsRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& LsRequest::user_id() const {
  // @@protoc_insertion_point(field_get:LsRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LsRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LsRequest.user_id)
}
inline std::string* LsRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:LsRequest.user_id)
  return _s;
}
inline const std::string& LsRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void LsRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LsRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LsRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:LsRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void LsRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LsRequest.user_id)
}

// string path = 2;
inline void LsRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& LsRequest::path() const {
  // @@protoc_insertion_point(field_get:LsRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LsRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LsRequest.path)
}
inline std::string* LsRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:LsRequest.path)
  return _s;
}
inline const std::string& LsRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void LsRequest::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* LsRequest::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* LsRequest::release_path() {
  // @@protoc_insertion_point(field_release:LsRequest.path)
  return _impl_.path_.Release();
}
inline void LsRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LsRequest.path)
}

// -------------------------------------------------------------------

// LsResponse

// bool success = 1;
inline void LsResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool LsResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool LsResponse::success() const {
  // @@protoc_insertion_point(field_get:LsResponse.success)
  return _internal_success();
}
inline void LsResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void LsResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:LsResponse.success)
}

// string error = 2;
inline void LsResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& LsResponse::error() const {
  // @@protoc_insertion_point(field_get:LsResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LsResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LsResponse.error)
}
inline std::string* LsResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:LsResponse.error)
  return _s;
}
inline const std::string& LsResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void LsResponse::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* LsResponse::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* LsResponse::release_error() {
  // @@protoc_insertion_point(field_release:LsResponse.error)
  return _impl_.error_.Release();
}
inline void LsResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LsResponse.error)
}

// repeated string files = 3;
inline int LsResponse::_internal_files_size() const {
  return _impl_.files_.size();
}
inline int LsResponse::files_size() const {
  return _internal_files_size();
}
inline void LsResponse::clear_files() {
  _impl_.files_.Clear();
}
inline std::string* LsResponse::add_files() {
  std::string* _s = _internal_add_files();
  // @@protoc_insertion_point(field_add_mutable:LsResponse.files)
  return _s;
}
inline const std::string& LsResponse::_internal_files(int index) const {
  return _impl_.files_.Get(index);
}
inline const std::string& LsResponse::files(int index) const {
  // @@protoc_insertion_point(field_get:LsResponse.files)
  return _internal_files(index);
}
inline std::string* LsResponse::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:LsResponse.files)
  return _impl_.files_.Mutable(index);
}
inline void LsResponse::set_files(int index, const std::string& value) {
  _impl_.files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:LsResponse.files)
}
inline void LsResponse::set_files(int index, std::string&& value) {
  _impl_.files_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:LsResponse.files)
}
inline void LsResponse::set_files(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:LsResponse.files)
}
inline void LsResponse::set_files(int index, const char* value, size_t size) {
  _impl_.files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LsResponse.files)
}
inline std::string* LsResponse::_internal_add_files() {
  return _impl_.files_.Add();
}
inline void LsResponse::add_files(const std::string& value) {
  _impl_.files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:LsResponse.files)
}
inline void LsResponse::add_files(std::string&& value) {
  _impl_.files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:LsResponse.files)
}
inline void LsResponse::add_files(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:LsResponse.files)
}
inline void LsResponse::add_files(const char* value, size_t size) {
  _impl_.files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:LsResponse.files)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LsResponse::files() const {
  // @@protoc_insertion_point(field_list:LsResponse.files)
  return _impl_.files_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LsResponse::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:LsResponse.files)
  return &_impl_.files_;
}

// -------------------------------------------------------------------

// ReadBlockRequest

// uint64 block_uuid = 1;
inline void ReadBlockRequest::clear_block_uuid() {
  _impl_.block_uuid_ = uint64_t{0u};
}
inline uint64_t ReadBlockRequest::_internal_block_uuid() const {
  return _impl_.block_uuid_;
}
inline uint64_t ReadBlockRequest::block_uuid() const {
  // @@protoc_insertion_point(field_get:ReadBlockRequest.block_uuid)
  return _internal_block_uuid();
}
inline void ReadBlockRequest::_internal_set_block_uuid(uint64_t value) {
  
  _impl_.block_uuid_ = value;
}
inline void ReadBlockRequest::set_block_uuid(uint64_t value) {
  _internal_set_block_uuid(value);
  // @@protoc_insertion_point(field_set:ReadBlockRequest.block_uuid)
}

// uint32 offset = 2;
inline void ReadBlockRequest::clear_offset() {
  _impl_.offset_ = 0u;
}
inline uint32_t ReadBlockRequest::_internal_offset() const {
  return _impl_.offset_;
}
inline uint32_t ReadBlockRequest::offset() const {
  // @@protoc_insertion_point(field_get:ReadBlockRequest.offset)
  return _internal_offset();
}
inline void ReadBlockRequest::_internal_set_offset(uint32_t value) {
  
  _impl_.offset_ = value;
}
inline void ReadBlockRequest::set_offset(uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:ReadBlockRequest.offset)
}

// uint32 length = 3;
inline void ReadBlockRequest::clear_length() {
  _impl_.length_ = 0u;
}
inline uint32_t ReadBlockRequest::_internal_length() const {
  return _impl_.length_;
}
inline uint32_t ReadBlockRequest::length() const {
  // @@protoc_insertion_point(field_get:ReadBlockRequest.length)
  return _internal_length();
}
inline void ReadBlockRequest::_internal_set_length(uint32_t value) {
  
  _impl_.length_ = value;
}
inline void ReadBlockRequest::set_length(uint32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:ReadBlockRequest.length)
}

// -------------------------------------------------------------------

// ReadBlockResponse

// bool success = 1;
inline void ReadBlockResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool ReadBlockResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool ReadBlockResponse::success() const {
  // @@protoc_insertion_point(field_get:ReadBlockResponse.success)
  return _internal_success();
}
inline void ReadBlockResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ReadBlockResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ReadBlockResponse.success)
}

// bytes data = 2;
inline void ReadBlockResponse::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ReadBlockResponse::data() const {
  // @@protoc_insertion_point(field_get:ReadBlockResponse.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadBlockResponse::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReadBlockResponse.data)
}
inline std::string* ReadBlockResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ReadBlockResponse.data)
  return _s;
}
inline const std::string& ReadBlockResponse::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ReadBlockResponse::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadBlockResponse::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadBlockResponse::release_data() {
  // @@protoc_insertion_point(field_release:ReadBlockResponse.data)
  return _impl_.data_.Release();
}
inline void ReadBlockResponse::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReadBlockResponse.data)
}

// string error = 3;
inline void ReadBlockResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& ReadBlockResponse::error() const {
  // @@protoc_insertion_point(field_get:ReadBlockResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadBlockResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReadBlockResponse.error)
}
inline std::string* ReadBlockResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ReadBlockResponse.error)
  return _s;
}
inline const std::string& ReadBlockResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void ReadBlockResponse::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadBlockResponse::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadBlockResponse::release_error() {
  // @@protoc_insertion_point(field_release:ReadBlockResponse.error)
  return _impl_.error_.Release();
}
inline void ReadBlockResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReadBlockResponse.error)
}

// uint32 bytes_read = 4;
inline void ReadBlockResponse::clear_bytes_read() {
  _impl_.bytes_read_ = 0u;
}
inline uint32_t ReadBlockResponse::_internal_bytes_read() const {
  return _impl_.bytes_read_;
}
inline uint32_t ReadBlockResponse::bytes_read() const {
  // @@protoc_insertion_point(field_get:ReadBlockResponse.bytes_read)
  return _internal_bytes_read();
}
inline void ReadBlockResponse::_internal_set_bytes_read(uint32_t value) {
  
  _impl_.bytes_read_ = value;
}
inline void ReadBlockResponse::set_bytes_read(uint32_t value) {
  _internal_set_bytes_read(value);
  // @@protoc_insertion_point(field_set:ReadBlockResponse.bytes_read)
}

// -------------------------------------------------------------------

// WriteBlockRequest

// uint64 block_uuid = 1;
inline void WriteBlockRequest::clear_block_uuid() {
  _impl_.block_uuid_ = uint64_t{0u};
}
inline uint64_t WriteBlockRequest::_internal_block_uuid() const {
  return _impl_.block_uuid_;
}
inline uint64_t WriteBlockRequest::block_uuid() const {
  // @@protoc_insertion_point(field_get:WriteBlockRequest.block_uuid)
  return _internal_block_uuid();
}
inline void WriteBlockRequest::_internal_set_block_uuid(uint64_t value) {
  
  _impl_.block_uuid_ = value;
}
inline void WriteBlockRequest::set_block_uuid(uint64_t value) {
  _internal_set_block_uuid(value);
  // @@protoc_insertion_point(field_set:WriteBlockRequest.block_uuid)
}

// bytes data = 2;
inline void WriteBlockRequest::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& WriteBlockRequest::data() const {
  // @@protoc_insertion_point(field_get:WriteBlockRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteBlockRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WriteBlockRequest.data)
}
inline std::string* WriteBlockRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:WriteBlockRequest.data)
  return _s;
}
inline const std::string& WriteBlockRequest::_internal_data() const {
  return _impl_.data_.Get();
}
inline void WriteBlockRequest::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteBlockRequest::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteBlockRequest::release_data() {
  // @@protoc_insertion_point(field_release:WriteBlockRequest.data)
  return _impl_.data_.Release();
}
inline void WriteBlockRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:WriteBlockRequest.data)
}

// uint32 offset = 3;
inline void WriteBlockRequest::clear_offset() {
  _impl_.offset_ = 0u;
}
inline uint32_t WriteBlockRequest::_internal_offset() const {
  return _impl_.offset_;
}
inline uint32_t WriteBlockRequest::offset() const {
  // @@protoc_insertion_point(field_get:WriteBlockRequest.offset)
  return _internal_offset();
}
inline void WriteBlockRequest::_internal_set_offset(uint32_t value) {
  
  _impl_.offset_ = value;
}
inline void WriteBlockRequest::set_offset(uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:WriteBlockRequest.offset)
}

// bool sync = 4;
inline void WriteBlockRequest::clear_sync() {
  _impl_.sync_ = false;
}
inline bool WriteBlockRequest::_internal_sync() const {
  return _impl_.sync_;
}
inline bool WriteBlockRequest::sync() const {
  // @@protoc_insertion_point(field_get:WriteBlockRequest.sync)
  return _internal_sync();
}
inline void WriteBlockRequest::_internal_set_sync(bool value) {
  
  _impl_.sync_ = value;
}
inline void WriteBlockRequest::set_sync(bool value) {
  _internal_set_sync(value);
  // @@protoc_insertion_point(field_set:WriteBlockRequest.sync)
}

// -------------------------------------------------------------------

// DeleteBlockRequest

// uint64 block_uuid = 1;
inline void DeleteBlockRequest::clear_block_uuid() {
  _impl_.block_uuid_ = uint64_t{0u};
}
inline uint64_t DeleteBlockRequest::_internal_block_uuid() const {
  return _impl_.block_uuid_;
}
inline uint64_t DeleteBlockRequest::block_uuid() const {
  // @@protoc_insertion_point(field_get:DeleteBlockRequest.block_uuid)
  return _internal_block_uuid();
}
inline void DeleteBlockRequest::_internal_set_block_uuid(uint64_t value) {
  
  _impl_.block_uuid_ = value;
}
inline void DeleteBlockRequest::set_block_uuid(uint64_t value) {
  _internal_set_block_uuid(value);
  // @@protoc_insertion_point(field_set:DeleteBlockRequest.block_uuid)
}

// -------------------------------------------------------------------

// GetBlockInfoRequest

// uint64 block_uuid = 1;
inline void GetBlockInfoRequest::clear_block_uuid() {
  _impl_.block_uuid_ = uint64_t{0u};
}
inline uint64_t GetBlockInfoRequest::_internal_block_uuid() const {
  return _impl_.block_uuid_;
}
inline uint64_t GetBlockInfoRequest::block_uuid() const {
  // @@protoc_insertion_point(field_get:GetBlockInfoRequest.block_uuid)
  return _internal_block_uuid();
}
inline void GetBlockInfoRequest::_internal_set_block_uuid(uint64_t value) {
  
  _impl_.block_uuid_ = value;
}
inline void GetBlockInfoRequest::set_block_uuid(uint64_t value) {
  _internal_set_block_uuid(value);
  // @@protoc_insertion_point(field_set:GetBlockInfoRequest.block_uuid)
}

// -------------------------------------------------------------------

// GetBlockInfoResponse

// bool exists = 1;
inline void GetBlockInfoResponse::clear_exists() {
  _impl_.exists_ = false;
}
inline bool GetBlockInfoResponse::_internal_exists() const {
  return _impl_.exists_;
}
inline bool GetBlockInfoResponse::exists() const {
  // @@protoc_insertion_point(field_get:GetBlockInfoResponse.exists)
  return _internal_exists();
}
inline void GetBlockInfoResponse::_internal_set_exists(bool value) {
  
  _impl_.exists_ = value;
}
inline void GetBlockInfoResponse::set_exists(bool value) {
  _internal_set_exists(value);
  // @@protoc_insertion_point(field_set:GetBlockInfoResponse.exists)
}

// uint64 size = 2;
inline void GetBlockInfoResponse::clear_size() {
  _impl_.size_ = uint64_t{0u};
}
inline uint64_t GetBlockInfoResponse::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t GetBlockInfoResponse::size() const {
  // @@protoc_insertion_point(field_get:GetBlockInfoResponse.size)
  return _internal_size();
}
inline void GetBlockInfoResponse::_internal_set_size(uint64_t value) {
  
  _impl_.size_ = value;
}
inline void GetBlockInfoResponse::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:GetBlockInfoResponse.size)
}

// string created_at = 3;
inline void GetBlockInfoResponse::clear_created_at() {
  _impl_.created_at_.ClearToEmpty();
}
inline const std::string& GetBlockInfoResponse::created_at() const {
  // @@protoc_insertion_point(field_get:GetBlockInfoResponse.created_at)
  return _internal_created_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBlockInfoResponse::set_created_at(ArgT0&& arg0, ArgT... args) {
 
 _impl_.created_at_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBlockInfoResponse.created_at)
}
inline std::string* GetBlockInfoResponse::mutable_created_at() {
  std::string* _s = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:GetBlockInfoResponse.created_at)
  return _s;
}
inline const std::string& GetBlockInfoResponse::_internal_created_at() const {
  return _impl_.created_at_.Get();
}
inline void GetBlockInfoResponse::_internal_set_created_at(const std::string& value) {
  
  _impl_.created_at_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBlockInfoResponse::_internal_mutable_created_at() {
  
  return _impl_.created_at_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBlockInfoResponse::release_created_at() {
  // @@protoc_insertion_point(field_release:GetBlockInfoResponse.created_at)
  return _impl_.created_at_.Release();
}
inline void GetBlockInfoResponse::set_allocated_created_at(std::string* created_at) {
  if (created_at != nullptr) {
    
  } else {
    
  }
  _impl_.created_at_.SetAllocated(created_at, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.created_at_.IsDefault()) {
    _impl_.created_at_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBlockInfoResponse.created_at)
}

// string checksum = 4;
inline void GetBlockInfoResponse::clear_checksum() {
  _impl_.checksum_.ClearToEmpty();
}
inline const std::string& GetBlockInfoResponse::checksum() const {
  // @@protoc_insertion_point(field_get:GetBlockInfoResponse.checksum)
  return _internal_checksum();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBlockInfoResponse::set_checksum(ArgT0&& arg0, ArgT... args) {
 
 _impl_.checksum_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBlockInfoResponse.checksum)
}
inline std::string* GetBlockInfoResponse::mutable_checksum() {
  std::string* _s = _internal_mutable_checksum();
  // @@protoc_insertion_point(field_mutable:GetBlockInfoResponse.checksum)
  return _s;
}
inline const std::string& GetBlockInfoResponse::_internal_checksum() const {
  return _impl_.checksum_.Get();
}
inline void GetBlockInfoResponse::_internal_set_checksum(const std::string& value) {
  
  _impl_.checksum_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBlockInfoResponse::_internal_mutable_checksum() {
  
  return _impl_.checksum_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBlockInfoResponse::release_checksum() {
  // @@protoc_insertion_point(field_release:GetBlockInfoResponse.checksum)
  return _impl_.checksum_.Release();
}
inline void GetBlockInfoResponse::set_allocated_checksum(std::string* checksum) {
  if (checksum != nullptr) {
    
  } else {
    
  }
  _impl_.checksum_.SetAllocated(checksum, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.checksum_.IsDefault()) {
    _impl_.checksum_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBlockInfoResponse.checksum)
}

// -------------------------------------------------------------------

// HeartBeatRequest

// string datanode_id = 1;
inline void HeartBeatRequest::clear_datanode_id() {
  _impl_.datanode_id_.ClearToEmpty();
}
inline const std::string& HeartBeatRequest::datanode_id() const {
  // @@protoc_insertion_point(field_get:HeartBeatRequest.datanode_id)
  return _internal_datanode_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartBeatRequest::set_datanode_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.datanode_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HeartBeatRequest.datanode_id)
}
inline std::string* HeartBeatRequest::mutable_datanode_id() {
  std::string* _s = _internal_mutable_datanode_id();
  // @@protoc_insertion_point(field_mutable:HeartBeatRequest.datanode_id)
  return _s;
}
inline const std::string& HeartBeatRequest::_internal_datanode_id() const {
  return _impl_.datanode_id_.Get();
}
inline void HeartBeatRequest::_internal_set_datanode_id(const std::string& value) {
  
  _impl_.datanode_id_.Set(value, GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::_internal_mutable_datanode_id() {
  
  return _impl_.datanode_id_.Mutable(GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::release_datanode_id() {
  // @@protoc_insertion_point(field_release:HeartBeatRequest.datanode_id)
  return _impl_.datanode_id_.Release();
}
inline void HeartBeatRequest::set_allocated_datanode_id(std::string* datanode_id) {
  if (datanode_id != nullptr) {
    
  } else {
    
  }
  _impl_.datanode_id_.SetAllocated(datanode_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.datanode_id_.IsDefault()) {
    _impl_.datanode_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HeartBeatRequest.datanode_id)
}

// repeated uint64 block_uuids = 2;
inline int HeartBeatRequest::_internal_block_uuids_size() const {
  return _impl_.block_uuids_.size();
}
inline int HeartBeatRequest::block_uuids_size() const {
  return _internal_block_uuids_size();
}
inline void HeartBeatRequest::clear_block_uuids() {
  _impl_.block_uuids_.Clear();
}
inline uint64_t HeartBeatRequest::_internal_block_uuids(int index) const {
  return _impl_.block_uuids_.Get(index);
}
inline uint64_t HeartBeatRequest::block_uuids(int index) const {
  // @@protoc_insertion_point(field_get:HeartBeatRequest.block_uuids)
  return _internal_block_uuids(index);
}
inline void HeartBeatRequest::set_block_uuids(int index, uint64_t value) {
  _impl_.block_uuids_.Set(index, value);
  // @@protoc_insertion_point(field_set:HeartBeatRequest.block_uuids)
}
inline void HeartBeatRequest::_internal_add_block_uuids(uint64_t value) {
  _impl_.block_uuids_.Add(value);
}
inline void HeartBeatRequest::add_block_uuids(uint64_t value) {
  _internal_add_block_uuids(value);
  // @@protoc_insertion_point(field_add:HeartBeatRequest.block_uuids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
HeartBeatRequest::_internal_block_uuids() const {
  return _impl_.block_uuids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
HeartBeatRequest::block_uuids() const {
  // @@protoc_insertion_point(field_list:HeartBeatRequest.block_uuids)
  return _internal_block_uuids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
HeartBeatRequest::_internal_mutable_block_uuids() {
  return &_impl_.block_uuids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
HeartBeatRequest::mutable_block_uuids() {
  // @@protoc_insertion_point(field_mutable_list:HeartBeatRequest.block_uuids)
  return _internal_mutable_block_uuids();
}

// -------------------------------------------------------------------

// HeartBeatResponse

// bool success = 1;
inline void HeartBeatResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool HeartBeatResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool HeartBeatResponse::success() const {
  // @@protoc_insertion_point(field_get:HeartBeatResponse.success)
  return _internal_success();
}
inline void HeartBeatResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void HeartBeatResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:HeartBeatResponse.success)
}

// string error = 2;
inline void HeartBeatResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& HeartBeatResponse::error() const {
  // @@protoc_insertion_point(field_get:HeartBeatResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartBeatResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HeartBeatResponse.error)
}
inline std::string* HeartBeatResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:HeartBeatResponse.error)
  return _s;
}
inline const std::string& HeartBeatResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void HeartBeatResponse::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* HeartBeatResponse::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* HeartBeatResponse::release_error() {
  // @@protoc_insertion_point(field_release:HeartBeatResponse.error)
  return _impl_.error_.Release();
}
inline void HeartBeatResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HeartBeatResponse.error)
}

// -------------------------------------------------------------------

// StatusResponse

// bool success = 1;
inline void StatusResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool StatusResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool StatusResponse::success() const {
  // @@protoc_insertion_point(field_get:StatusResponse.success)
  return _internal_success();
}
inline void StatusResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void StatusResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:StatusResponse.success)
}

// string error = 2;
inline void StatusResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& StatusResponse::error() const {
  // @@protoc_insertion_point(field_get:StatusResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StatusResponse.error)
}
inline std::string* StatusResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:StatusResponse.error)
  return _s;
}
inline const std::string& StatusResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void StatusResponse::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusResponse::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* StatusResponse::release_error() {
  // @@protoc_insertion_point(field_release:StatusResponse.error)
  return _impl_.error_.Release();
}
inline void StatusResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StatusResponse.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_fs_2eproto
